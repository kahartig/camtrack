# convert_cam_to_arl.jpy
# by Kara Hartig
# last modified: April 24, 2020
# based on:
#     convert_cam_to_arl.py by Pratap Singh
#     wrfout2arl.html by Yaqiang Wang
# note: this script is in Jython, not standard Python, and must be run with MeteoInfo
#
# Convert a netcdf output file from the Community Atmosphere Model, version 4, to
# .arl input format for HYSPLIT backtracking code
# Run with the MeteoInfo software suite (http://www.meteothinker.com/index.html) by
# Yaqiang Wang.
# As it runs, the code produces and deletes a file called cam_to_arl_temp.arl in the output 
# directory.  This file must not be tampered with while the code is running.
# To run within MeteoInfo main directory:
#    on Unix: >>./milab.sh convert_cam_to_arl.jpy
#    on Mac: >>./milab_mac.sh convert_cam_to_arl.jpy

# Set winter years
winter_file = '0708'  # file extension for winter year

# Set data folders
indatadir = '/n/tzipermanfs2/khartig/arctic_air_suppression/PI/CAM_output_winters/'
outdatadir = '/n/tzipermanfs2/khartig/arctic_air_suppression/PI/ARL_winters/'

# Read the input netCDF data files
#     variables are spread across 4 netCDF files
#     dictionaries will be used to access the relevant file
#     ASSUMES that all files (h1 thru h4) have same metadata (same time period, lat/lon, etc)
name_to_h = dict.fromkeys(['CLDHGH', 'CLDICE', 'CLDLIQ', 'CLDLOW', 'CLDMED',
                               'CLDTOT', 'CLOUD', 'CONCLD', 'FICE', 'ICIMR', 'ICLDIWP', 'ICLDTWP', 'ICWMR',
                               'Q', 'QFLX', 'QREFHT', 'RELHUM', 'SFCLDICE', 'SFCLDLIQ', 'TGCLDCWP',
                               'TGCLDIWP', 'TGCLDLWP', 'TMQ'], 'h1')
name_to_h.update(dict.fromkeys(['FLDS', 'FLDSC', 'FLNS', 'FLNSC', 'FLNT',
                                'FLNTC', 'FLUT', 'FLUTC', 'FSDS', 'FSDSC', 'FSDTOA', 'FSNS', 'FSNSC', 'FSNT',
                                'FSNTC', 'FSNTOA', 'FSNTOAC', 'FSUTOA', 'LHFLX', 'LWCF', 'QRL', 'QRS', 'SHFLX',
                                'SOLIN', 'SWCF'], 'h2'))
name_to_h.update(dict.fromkeys(['OMEGA', 'OMEGAT', 'PBLH', 'PHIS', 'PRECC',
                                'PRECL', 'PRECT', 'PS', 'PSL', 'SNOWHICE', 'SNOWHLND', 'TAUX', 'TAUY', 'U',
                                'U10', 'UU', 'V', 'VQ', 'VT', 'VU', 'VV', 'Z3'], 'h3'))
name_to_h.update(dict.fromkeys(['ICEFRAC', 'LANDFRAC', 'OCNFRAC', 'T', 'T200',
                                'T500', 'T850', 'TREFHT', 'TREFHTMN', 'TREFHTMX', 'TS', 'TSMN', 'TSMX'], 'h4'))
in_file_h1 = addfile(os.path.join(indatadir, 'pi_3h_' + winter_file + '_h1.nc'))
in_file_h2 = addfile(os.path.join(indatadir, 'pi_3h_' + winter_file + '_h2.nc'))
in_file_h3 = addfile(os.path.join(indatadir, 'pi_3h_' + winter_file + '_h3.nc'))
in_file_h4 = addfile(os.path.join(indatadir, 'pi_3h_' + winter_file + '_h4.nc'))
print 'opened netcdf file(s)' 
h_to_file = {'h1': in_file_h1, 'h2': in_file_h2, 'h3': in_file_h3, 'h4': in_file_h4}

# Load file for sample data (variables shared across all files)
sample_file = in_file_h3  # contains 3-D wind data
sample_variable = sample_file['U']  # sample variable for calculating dimensions and levels

# Touch the output file without writing to it:
out_filename = os.path.join(outdatadir, 'pi_3h_' + winter_file + '.arl')
open(out_filename, 'a').close();

# Map CAM variables to ARL variables
#    Surface variables:
varmap_2d = {'PS': 'PRSS', 'TREFHT': 'T02M', 'U10': 'U10M'}
unitmap_2d = {'PS': 0.01, 'TREFHT': 1., 'U10': 1.}
#    Full domain variables:
varmap_3d = {'T': 'TEMP', 'U': 'UWND', 'V': 'VWND', 'OMEGA': 'WWND', 'Z3': 'HGTS', 'RELHUM': 'RELH'}
unitmap_3d = {'T': 1., 'U': 1., 'V': 1., 'OMEGA': 0.01, 'Z3': 1., 'RELHUM': 1.}

# dimensions of (3-D) input netCDF variables
lon_index = 3
lat_index = 2
level_index = 1
#time_index = 0
nx = sample_variable.dimlen(lon_index)  # longitude
ny = sample_variable.dimlen(lat_index)  # latitude
nz = sample_variable.dimlen(level_index)  # vertical level

# convert vertical level coefficients to ECMWF-format levels
hyam = sample_file['hyam'][:]
hybm = sample_file['hybm'][:]
P_0 = sample_file.read('P0').getFloat(0)  # retrieves value for P_0 from file object
P_0_units = str(sample_file['P0'].attrvalue('units')[0])
if P_0_units != 'Pa':
	raise ValueError("Reference pressure P0 is not in units of Pa. Change definition of 'levels' so that integer part 'a' is in hPa.")
a = hyam[::-1] * P_0 / 100.0  # reverse index order to get surface -> TOA; factor of 100 to convert to hPa
b = hybm[::-1]  # reverse index order to get surface -> TOA; dimensionless, no need to convert units
levels = [int(round(a[ind])) + b[ind] for ind in range(len(a))]

# loop over times, append each to end of ARL file
num_times = sample_file.timenum()
fhour = 0  # Offset for initial time; incremented for each timestamp
for t in range(0, num_times):
    # Set temporary output ARL data file
    temp_filename = os.path.join(outdatadir, 'cam_to_arl_temp.arl')
    temp_file = addfile(temp_filename, 'c', dtype='arl')
    temp_file.setlevels(levels)
    temp_file.set2dvar(varmap_2d.values())
    for l in levels:
        temp_file.set3dvar(varmap_3d.values())

    # Write ARL data file
    temp_file.setx(sample_variable.dimvalue(lon_index))
    temp_file.sety(sample_variable.dimvalue(lat_index))
    timestamp = sample_file.gettime(t)
    print 'Time stamp: ' + str(timestamp)
    # In getdatahead below, integer is "vertical coordinate system flag":
    #     1 (sigma fraction), 2 (pressure mb), 3 (terrain fraction), 4 (hybrid sigma-pressure)
    data_header = temp_file.getdatahead(sample_file.proj, 'CAM4', 4, fhour)
    # modify data header grid parameter(s)
    #    for lat-lon grid, Pole Longitude must be maximum longitude value
    data_header.POLE_LON = max(sample_variable.dimvalue(lon_index))
    # Pre-write index record without data record - will be over-written later
    temp_file.writeindexrec(timestamp, data_header)

    # List of data records for this timestamp
    full_data_record = []

    # Write 2-D Variables: surface pressure
    surface_data_record = []
    for camkey,arlkey in varmap_2d.items():
        variable_file = h_to_file[name_to_h[camkey]]
        variable = variable_file[camkey][t, :, :] * unitmap_2d[camkey]
        single_data_record = temp_file.writedatarec(timestamp, 0, arlkey, fhour, 99, variable)  # write surface level (index 0)
        surface_data_record.append(single_data_record)
    full_data_record.append(surface_data_record)

    # Write 3-D Variables
    #    loop over level indices in reverse order
    #    CAM levels run TOA -> surface but HYSPLIT is expecting surface -> TOA
    #    write to ARL in reverse order: level index nz-1 (surface) -> level 1 (surface) and 0 (TOA) -> nz (TOA)
    for idx_lev in range(nz-1, -1, -1):
        level_data_record = []
        for camkey,arlkey in varmap_3d.items():
            variable_file = h_to_file[name_to_h[camkey]]
            variable = variable_file[camkey][t, idx_lev, :, :] * unitmap_3d[camkey]
            single_data_record = temp_file.writedatarec(timestamp, nz - idx_lev, arlkey, fhour, 99, variable)
            level_data_record.append(single_data_record)
        full_data_record.append(level_data_record)

    # Re-write index record with data record
    temp_file.writeindexrec(timestamp, data_header, full_data_record)
    temp_file.close()
    # Append the temp output file to the main output file
    os.system("cat " + temp_filename + " >> " + out_filename)
    # Delete the temp output file
    os.system("rm " + temp_filename)
    fhour += 1
    if fhour >= 99:
        fhour = 99
print 'Finished!'
